// THIS FILE IS GENERATED BY THE EPOXY FFI BINDIGS GENERATOR VERSION 0.1.0.

// ignore_for_file: always_specify_types

import 'dart:async';
import 'dart:ffi';

import '/Users/chinmaygarde/VersionControlled/engine/src/out/host_debug_unopt_arm64/gen/flutter/impeller/stator/renderer/renderer.epoxy.dart';
import '/Users/chinmaygarde/VersionControlled/engine/src/out/host_debug_unopt_arm64/gen/flutter/impeller/stator/objffi/objffi.epoxy.dart';

abstract class OBJFFIObject implements Finalizable {
  OBJFFIObject(this.peer) {
    objffi.Retain(peer);
    finalizer.attach(this, peer, detach: this);
  }

  bool isDisposed() {
    return peer == nullptr;
  }

  void dispose() {
    if (peer == nullptr) {
      return;
    }
    finalizer.detach(this);
    objffi.Release(peer);
    peer = nullptr;
  }

  Pointer<Void> peer;

  static var finalizer = NativeFinalizer(objffi.ReleasePTR);
}

final class Texture extends OBJFFIObject {
  Texture(this.texture) : super(texture.cast());

  FFITexturePointer texture;
}

final class Swapchain extends OBJFFIObject {
  Swapchain(this.swapchain) : super(swapchain.cast());

  Texture acquireNextDrawable() {
    final texture = renderer.SwapchainNextDrawableNew(swapchain);
    final wrapped = Texture(texture);
    objffi.Release(texture.cast());
    return wrapped;
  }

  bool presentDrawable(Texture texture) {
    final result = renderer.SwapchainPresentDrawable(swapchain, texture.texture);
    texture.dispose();
    return result;
  }

  FFISwapchainPointer swapchain;
}

final class Context extends OBJFFIObject {
  Context(this.context) : super(context.cast());

  Swapchain copySwapchain() {
    return Swapchain(renderer.ContextSwapchainCopy(context));
  }

  FFIContextPointer context;
}

final class RenderTarget extends OBJFFIObject {
  RenderTarget(this.target) : super(target.cast());

  FFIRenderTargetPointer target;
}

final class Color {
  Color(this.red, this.green, this.blue, this.alpha);

  Color.transparentBlack();

  double red = 0.0;
  double green = 0.0;
  double blue = 0.0;
  double alpha = 0.0;
}

final class ColorAttachment extends OBJFFIObject {
  ColorAttachment(this.attachment) : super(attachment.cast());

  LoadAction get loadAction => _loadAction;

  set loadAction(LoadAction action) {
    if (action == _loadAction) {
      return;
    }
    renderer.ColorAttachmentSetLoadAction(attachment, action.index);
    _loadAction = action;
  }

  StoreAction get storeAction => _storeAction;

  set storeAction(StoreAction action) {
    if (action == _storeAction) {
      return;
    }
    renderer.ColorAttachmentSetStoreAction(attachment, action.index);
    _storeAction = action;
  }

  Texture? get texture => _texture;

  set texture(Texture? texture) {
    if (_texture == texture) {
      return;
    }

    _texture = texture;
    renderer.ColorAttachmentSetTexture(attachment, _texture != null ? _texture!.texture : nullptr);
  }

  Texture? get resolveTexture => _resolveTexture;

  set resolveTexture(Texture? texture) {
    if (_resolveTexture == texture) {
      return;
    }

    _resolveTexture = texture;
    renderer.ColorAttachmentSetResolveTexture(attachment, _resolveTexture != null ? _resolveTexture!.texture : nullptr);
  }

  Color get clearColor => _clearColor;

  set clearColor(Color color) {
    _clearColor = color;
    final ffiColor = renderer.ColorAlloc();
    ffiColor.ref.red = color.red;
    ffiColor.ref.green = color.green;
    ffiColor.ref.blue = color.blue;
    ffiColor.ref.alpha = color.alpha;
    renderer.ColorAttachmentSetClearColor(attachment, ffiColor);
    renderer.ColorFree(ffiColor);
  }

  FFIColorAttachmentPointer attachment;
  Texture? _texture;
  Texture? _resolveTexture;
  LoadAction _loadAction  = LoadAction.DontCare;
  StoreAction _storeAction = StoreAction.DontCare;
  Color _clearColor = Color.transparentBlack();
}

final class DepthAttachment extends OBJFFIObject {
  DepthAttachment(this.attachment) : super(attachment.cast());

  LoadAction get loadAction => _loadAction;

  set loadAction(LoadAction action) {
    if (action == _loadAction) {
      return;
    }
    renderer.DepthAttachmentSetLoadAction(attachment, action.index);
    _loadAction = action;
  }

  StoreAction get storeAction => _storeAction;

  set storeAction(StoreAction action) {
    if (action == _storeAction) {
      return;
    }
    renderer.DepthAttachmentSetStoreAction(attachment, action.index);
    _storeAction = action;
  }

  Texture? get texture => _texture;

  set texture(Texture? texture) {
    if (_texture == texture) {
      return;
    }

    _texture = texture;
    renderer.DepthAttachmentSetTexture(
        attachment, _texture != null ? _texture!.texture : nullptr);
  }

  Texture? get resolveTexture => _resolveTexture;

  set resolveTexture(Texture? texture) {
    if (_resolveTexture == texture) {
      return;
    }

    _resolveTexture = texture;
    renderer.DepthAttachmentSetResolveTexture(attachment,
        _resolveTexture != null ? _resolveTexture!.texture : nullptr);
  }

  double get clearDepth => _clearDepth;

  set clearDepth(double depth) {
    if (_clearDepth == depth) {
      return;
    }

    _clearDepth = depth;
    renderer.DepthAttachmentSetClearDepth(attachment, _clearDepth);
  }

  FFIDepthAttachmentPointer attachment;
  Texture? _texture;
  Texture? _resolveTexture;
  LoadAction _loadAction = LoadAction.DontCare;
  StoreAction _storeAction = StoreAction.DontCare;
  double _clearDepth = 0.0;
}

final class StencilAttachment extends OBJFFIObject {
  StencilAttachment(this.attachment) : super(attachment.cast());

  LoadAction get loadAction => _loadAction;

  set loadAction(LoadAction action) {
    if (action == _loadAction) {
      return;
    }
    renderer.StencilAttachmentSetLoadAction(attachment, action.index);
    _loadAction = action;
  }

  StoreAction get storeAction => _storeAction;

  set storeAction(StoreAction action) {
    if (action == _storeAction) {
      return;
    }
    renderer.StencilAttachmentSetStoreAction(attachment, action.index);
    _storeAction = action;
  }

  Texture? get texture => _texture;

  set texture(Texture? texture) {
    if (_texture == texture) {
      return;
    }

    _texture = texture;
    renderer.StencilAttachmentSetTexture(
        attachment, _texture != null ? _texture!.texture : nullptr);
  }

  Texture? get resolveTexture => _resolveTexture;

  set resolveTexture(Texture? texture) {
    if (_resolveTexture == texture) {
      return;
    }

    _resolveTexture = texture;
    renderer.StencilAttachmentSetResolveTexture(attachment,
        _resolveTexture != null ? _resolveTexture!.texture : nullptr);
  }

  int get clearStencil => _clearStencil;

  set clearStencil(int stencil) {
    if (stencil == _clearStencil) {
      return;
    }
    _clearStencil = stencil;
    renderer.StencilAttachmentSetClearStencil(attachment, _clearStencil);
  }

  FFIStencilAttachmentPointer attachment;
  Texture? _texture;
  Texture? _resolveTexture;
  LoadAction _loadAction = LoadAction.DontCare;
  StoreAction _storeAction = StoreAction.DontCare;
  int _clearStencil = 0;
}

final Context context = Context(renderer.GetGlobalContext());
final Swapchain swapchain = context.copySwapchain();

void main () {
  Timer.periodic(const Duration(milliseconds: 16), (timer) {
    final texture = swapchain.acquireNextDrawable();
    swapchain.presentDrawable(texture);
  });
}
